---
title: "Confident Spatial Analysis and Statistics in R & GeoDa"
author: "Nick Bearman - Geospatial Training Solutions"
output:
  pdf_document: default
  html_document:
    df_print: paged
date: "Thu 13th April 2023"
---

```{r setup, echo=FALSE}
#set working directory to /data-user
knitr::opts_knit$set(root.dir = 'C:/Users/nick/Dropbox/Work/course-repos/04-confident-spatial-analysis-r-geoda/data-user')
```

Learning Outcomes: | R Functions & Libraries:  
-------- | --------  
Understand Linked Displays in GeoDa  |  *brushing* (pg. 1)  
Perform Local Indicators of Spatial Association | *LISA* (pg. 3)   
Understand how to read in a variety of formats | `st_read()` (pg. 6)  
Know how to reorder data | `order()` (pg. 16) 
Know how to use buffers within R  | `st_buffer()` (pg. 19)   
<!-- Understand creating and using functions within R | `function ()` (pg. 13)  -->  
<!-- Tables have a max line length, if it is too long, the table gets shrunk -->

# Practical 3: Spatial Decision Making - SP Version

Public transport has an important role to play in tackling deprivation. We can use RStudio to see where the trams in Manchester run and how they relate to deprived areas. 

Firstly, load the tramline data, available as a GeoJSON file. This is a different type of file to a shape file and is an XML based format (open it in Notepad if you are interested in how it is structured). `readOGR()` can read all sorts of file formats, so we can adapt the code easily. 

```{r, comment=NA, message=FALSE, warning=FALSE, results='hide'}
library(rgdal)
#read in and join manchester data
  manchester_lsoa <- readOGR(".", "GreaterManchester_lsoa_2011")
imd <- read.csv("imd.csv", header = TRUE)
  #delete columns we don't need
  imd <- imd[,1:7]
#rename columns
colnames(imd) <- c("LSOAcode","LSOAname","LADcode","LADname","IMDscore","IMDrank","IMDdecile")
  manchester_lsoa@data <- merge(manchester_lsoa@data,imd,by.x="CODE",by.y="LSOAcode", all.x=TRUE)
  head(manchester_lsoa@data)
  
#download data
  download.file("http://www.nickbearman.me.uk/data/r/tram.zip","tram.zip")
#unzip
  unzip("tram.zip")
#read in tramline data
  tramlines <- readOGR(dsn = "tramlines.geojson")
#if this doesn't work, try:
# tramlines <- readOGR(dsn = "tramlines.geojson", layer="OGRGeoJSON")
```

We also need the tram stations, which are only available as a CSV file with Eastings and Northings. 

```{r, comment=NA, message=FALSE, warning=FALSE, results='hide'}
#read in CSV with tram station locations
  tram_stations_CSV <- read.csv("metrolink-stations.csv", header = TRUE)
```

Read the CSV file in (metrolink-stations.csv) and it should look like this:

```{r, comment=NA}
head(tram_stations_CSV)
```

We now need to convert this to a `SpatialPointsDataFrame`, like with the crime data in the Introduction course. 

From `head(tram_stations_CSV)`, we can see that the data consists of a number of columns, each with a heading. Two of these are called **X** and **Y**. These are the columns that give the coordinates (Eastings and Northings, as they are in BNG) of each station in the data you have just downloaded. There are also other columns, with various information. At the moment, the data is just in a data frame object - not any kind of spatial object.  To turn it into a SpatialPointsDataFrame, enter the following:

```{r, comment=NA,warning=FALSE,message=FALSE}
#extract coordinates
  coords <- cbind(Easting = tram_stations_CSV$X, Northing = tram_stations_CSV$Y)
#create spatialPointsDataFrame, removing coordinates from the @data element
#we can use the same projection information as manchester_lsoa as we know it is identical
  tram_stations <- SpatialPointsDataFrame(coords, tram_stations_CSV[, -(1:2)], 
                                    proj4string = manchester_lsoa@proj4string)
```

This creates a ```SpatialPointsDataFrame``` object. This second line (starting `coords`) prepares the coordinates into a form that the ```SpatialPointsDataFrame``` can use. The ```SpatialPointsDataFrame``` function on the forth line takes three arguments - the first is coordinates, created in the line above. The second argument is the data frame **minus** (i.e. not including) columns 1 and 2 - this is what ```-(1:2)``` indicates.  These columns provide all the non-geographical data from the data frame.  The third is the coordinate system that the data is currently in (British National Grid). The resulting object ```tram_stations``` is a spatial points geographical shape object,  whose points are each recorded crime in the data set you download.  

Try `head(tram_stations@data)` to see the attribute table, similar to earlier. 

We can also plot the data, on top of the Greater Manchester LSOAs. Note the change in colour (`col`) and size (`cex` for points and `lwd` for lines), to make the lines and stations more visible. We can also use different symbols, by substituting in `pch = 1` for `pch="."`. Try searching in Google "R plot pch" and see what the different options are. 

```{r, comment=NA,warning=FALSE,message=FALSE}
#plot LSOAs
plot(manchester_lsoa)
#plot tram lines, in blue
plot(tramlines, col = "blue", lwd = 5, add = TRUE)
#plot stations, in red
plot(tram_stations, pch = ".", col = "red", cex = 5, add = TRUE)
```

We can see what the deprivation level is at each tram station, using a point in polygon analysis. The points are the tram stations and the polygons are the LSOAs. 

```{r, comment=NA,warning=FALSE,message=FALSE,error=FALSE}
# This is another R package, allowing GIS overlay operations
  library(rgeos) 
# this extracts the tram stations that are over the LSOAs (all of them in our case)
  z <- tram_stations[!is.na(over(tram_stations, geometry(manchester_lsoa))),]
# this takes the attribute data from the LSOA that contain the tram_stations, 
  #and adds it to the data frame of z     
    z@data <- data.frame(z@data, na.omit(over(tram_stations, manchester_lsoa)))
#this copies the project from tram_stations to z    
    z@proj4string <- tram_stations@proj4string
#copy z to tram_stations_joined
    tram_stations_joined <- z
#preview data
    head(tram_stations_joined)
```

Z is just a temporary variable to hold the updated tram_stations information. If we wanted to be tidy, we should really delete the z variable when we have finished: `rm(z)` 

## Reordering data

There is an `order()` function in R that allows us to reorder data. This is particularly useful if we want to display the 10 most and 10 least deprived stations! This code below creates a new variable with the data in a different order.

```{r, comment = NA}
tram_stations_joined_reordered <- 
  tram_stations_joined[order(tram_stations_joined@data$IMDscore, decreasing = TRUE),]
```

We can then plot the top and bottom 10 stations:

```{r, comment = NA}
plot(tram_stations_joined_reordered[1:10,], col = "red")
plot(tram_stations_joined_reordered[81:91,], col = "blue", add = TRUE)
```
  
So, which tram stop is the most deprived? and which is the least deprived?
  
```{r, comment = NA,warning=FALSE,message=FALSE,error=FALSE, results='hide'}
#most deprived
tram_stations_joined_reordered[1,]
#least deprived
tram_stations_joined_reordered[91,]
```

Can you create a map similar to this (see over), with the 10 most deprived stations in red and the top 10 least deprived stations in blue as well as identifying the most and least deprived stations? As an optional extra, see if you can include an appropriate legend and title.

```{r, comment = NA, echo=FALSE}
plot(tramlines)
plot(tram_stations, pch=".", cex = 3, add = TRUE)
plot(tram_stations_joined_reordered[1:10,], pch=".", cex = 5, col = "red", add = TRUE)
plot(tram_stations_joined_reordered[81:91,], pch=".", cex = 5, col = "blue", add = TRUE)
plot(tram_stations_joined_reordered[1,], pch=".", cex = 9, col = "red", add = TRUE)
plot(tram_stations_joined_reordered[91,], pch=".", cex = 9, col = "blue", add = TRUE)
```

## Creating a Function (optional exercise)

The code for doing a spatial join can easily be turned into a function within R. A function allows us to repeat a section of code with different data, without having to type out all of the lines again. This also hides some of the complexity from the user. For example, if we wanted to do a spatial join between railway stations and LSOAs, we could just substitute railway stations for trams. A function we have written ourselves works exactly the same way as many other functions we have used (`read.csv()`, `readOGR()`, etc.). Running a `SpatialJoin()` function we have written would look a bit like this:

```{r, comment=NA,warning=FALSE,message=FALSE, eval = FALSE}
tram_stations_joined <- SpatialJoin(tram_stations, manchester_lsoa)
```

Where `tram_stations` and `manchester_lsoa` are the parameters, `SpatialJoin` the function name and `tram_stations_joined` the output. Currently, if you ran the line above, R would give an error message, as it doesn't know what that function is. To create the function (and it will appear in the environment list on the right) run this code:

```{r, comment=NA,warning=FALSE,message=FALSE}
#function to join points with the attribute data of the polygons they overlay
SpatialJoin <- function(pts, polys) {
  #error checking
    if (!inherits(polys, "SpatialPolygonsDataFrame")) 
        stop("MUST BE SP SpatialPolygonsDataFrame OBJECT")
    if ((inherits(pts, "SpatialPointsDataFrame") | inherits(pts, "SpatialPoints")) == FALSE) 
        stop("Must be sp SpatialPointsDataFrame object")
  #extract points in overlay
    z <- pts[!is.na(over(pts, geometry(polys))),]
  #join attribute data  
    z@data <- data.frame(z@data, na.omit(over(pts,polys)) )
  #update projection
    z@proj4string <- pts@proj4string
  #return z
    z
}     
```

In a function it is common to use generic terms to refer to the inputs and outputs (e.g. pts, polys, z), because the function doesn't know (or care) whether we are dealing with tram stations or railway stations - it just cares that it is a point (or polygon) layer. 

This is where error checking comes in, which is what takes up the first half of the function. These check whether the poly variable is a polygon and the pts variable a points layer. If they are not, it will stop running and generate an error message. Try creating the function and running it. 

We can then repeat the process of working out which train station is the most and least deprived. The train stations for Manchester are included in the tram.zip file as `rail-stations.geojson` (originally from https://data.gov.uk/dataset/metrolink-and-rail-stations). Try writing the code to read the data in, join it, reorder it and display it on the map. 


## Tram Stop Buffers

Currently we have been looking at just the LSOA each tram stop is within. However we could look at the LSOAs that are within a set distance (for example a 15 minute walk) of each tram stop. Why do you think we might we want to do this?

For this, we need to use a buffer - a circle of a set distance around each tram stop. At a speed of 3 mph, this is equal to about 1.2km. We can use the `gBuffer` function, from the `rgeos` library. 

```{r, comment = NA}
#plot the tram stations
  plot(tram_stations_joined)
#calculate the buffer (distance is 1200 meters)
  tram_stations_joined_buffer <- gBuffer(tram_stations_joined, width = 1200, byid = TRUE)
#plot the buffer (add to existing plot)
  plot(tram_stations_joined_buffer, add = TRUE)
```

We now have the buffers (the circles) for each tram station. There are a number of different ways we can look at how the buffers and LSOAs relate to one another. We are going to look at a quite simple approach - convert the LSOAs to points and for each buffer take the average deprivation level of the LSOAs within the buffer. 

**There are a number of limitations with this method and this is something to think about as you work through this process: how could you do the analysis differently in the future?**

First, we need to convert the LSOA polygons into points. Fortunately, there is a function (`gCentroid()`) which is part of the `rgeos` package which will do this for us. This calculates the centre point (centroid) for each LSOA. The function creates a `SpatialPoints` variable, which doesn't have an attribute table (`@data`), so we need to copy this over manually.

```{r, comment = NA}
#convert polygons to points  
  manchester_lsoa_points <- gCentroid(manchester_lsoa, byid = TRUE)  
  plot(manchester_lsoa_points)
#create coordinates
  coords = data.frame(manchester_lsoa_points@coords[,1:2])
#create SpatialPointsDataFrame using coords and data
  manchester_lsoa_points <- SpatialPointsDataFrame(coords, data=data.frame(
    manchester_lsoa@data$IMDscore), proj4string= manchester_lsoa@proj4string)
#plot points  
  plot(manchester_lsoa_points)
#show head
  head(manchester_lsoa_points@data)
#plot first tram station
  plot(tram_stations_joined_buffer[1,])  
#plot lsoa points on top
  plot(manchester_lsoa_points, add = TRUE)  
```

Now we have the train stations buffers as polygons and the LSOAs as points (as shown in the plot above). We can do the overlay manually by plotting the different data sets on top of one another (as we did above). However, R is unable to link each tramstop with the LSOAs within the buffer. For this we need to get R to do the overlay and save the associated information - i.e. the average IMD score for each tram station, based on the buffer. 

```{r, comment = NA}
#Create point in polygon list
  o <- over(tram_stations_joined_buffer,manchester_lsoa_points,returnList=TRUE)
#View length of the list
  length(o)
#If we examine the object o, we will see also see that this comprises a list of dataframes. 
#The summary function tells you about an object - head, is used to wrap around the function 
#so only the first six elements are shown
  head(summary(o))
#View an item from the list (in this case sixth) (i.e. the sixth tram station and all of 
#the LSOAs that are linked with it)
  o[[6]]
#get a list of those LSOAs that are within this buffer using the rownames
#make them numeric
  row_o <- as.numeric(rownames(o[[6]]))
#plot tram station buffer number 6
  plot(tram_stations_joined_buffer[6,])
#Plot all the LSOA centroids
  plot(manchester_lsoa_points,pch=19,cex=.5,col="#7F7F7F",add=TRUE)
#Plot those LSOA centroids which are inside the buffer - i.e. we use the row_o to select the rows
  plot(manchester_lsoa_points[row_o,],pch=15,cex=1,col="#FF4500",add=TRUE)
```

This shows the tram station buffer (the circle), all of the LSOA centroids (grey dots) and those LSOA centroids within the buffer (red squares). For each tram buffer, we need to calculate the average IMD score, as we are likely to have a range of deprivation levels within the tram station buffer. The `colMeans()` function will calculate the mean value for each column (as you might have guessed!). We want to do this for each tram station buffer and the `lapply()` function allows us to do this - to apply a function (`colMeans()`) across the list of tram station buffers. We can then join this back onto the tram_stations data frame. 

```{r, comment = NA}
  average_deprivation <- lapply(o, colMeans)
#View the first six items from the list
  average_deprivation[1:6]
#collapse list back into a normal data frame
  tram_deprivation <- data.frame(matrix(unlist(average_deprivation),
                                        nrow=length(average_deprivation), byrow=T))
#Change the column names to something sensible
  colnames(tram_deprivation) <- c("average_deprivation")
#This should look like
  head(tram_deprivation)
#Join - the ordering has not been changed so this is valid
  tram_stations@data <- cbind(tram_stations@data,tram_deprivation)
#show data
  head(tram_stations@data)
```  

We now have the average deprivation for each tram stop. **How is this different to our previous measure? What are the limitations?** Plot a map of your results. 
  
- Discuss your results with a neighbour. How could the deprivation be calculated differently? 
- Try running the analysis with a different buffer. How easy is this within R compared to another GIS? 
- How about doing a polygon polygon overlay? How easy is this in R compared to another GIS? *See http://gis.stackexchange.com/questions/140504/extracting-intersection-areas-in-r for some interesting suggestions.*

*If you want to install additional libraries, you can do this, but on centrally managed machines, it will only install onto that machine, so if you use a different machine you may need to rerun the installation command.*

## Future Developments (optional exercise)

We can extend this principle to look at groups of tram stops (either using just the stop location, or the buffer approach. For example, let's say there are some prospective new tram routes which could be built (see `future_tramlines` and `future_tramstops`).

We need to decide which route is the most important. For this exercise we are going to say that the route that gives access to the most deprived area(s) will be our recommended route (obviously there are many other factors that could be involved!). 

**Analyse the prospective new routes to see which reaches the areas with highest deprivation levels.**



-----  
  
  
This practical was written using R 4.2.0 (2022-04-22) and RStudio 2022.02.3 by Dr. Nick Bearman (nick@geospatialtrainingsolutions.co.uk). It has also been tested in R 4.2.0 (2022-04-22) and RStudio 2022.02.3 (RStudio Cloud).

This work (Confident Spatial Analysis and Statistics in R & GeoDa - Practical 3: Spatial Decision Making - SP Version) is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/4.0/. <img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/cc.svg?ref=chooser-v1"><img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/by.svg?ref=chooser-v1"><img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/nc.svg?ref=chooser-v1"><img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/sa.svg?ref=chooser-v1">

The latest version of the PDF is available from https://github.com/nickbearman/confident-spatial-analysis. This is v5.1 and this was created on `r format(Sys.time(), '%d %B %Y')`.


