---
title: "Confident Spatial Analysis and Statistics in R & GeoDa"
author: "Nick Bearman - Geospatial Training Solutions"
output:
  pdf_document: default
  html_document:
    df_print: paged
date: "Fri 24th June 2022"
---

```{r setup, echo=FALSE}
#set working directory to /data-user
knitr::opts_knit$set(root.dir = 'C:/Users/nick/Dropbox/Work/course-repos/04-confident-spatial-analysis-r-geoda/data-user')
```

Learning Outcomes: | R Functions & Libraries:  
-------- | --------  
Understand Linked Displays in GeoDa  |  *brushing* (pg. 1)  
Perform Local Indicators of Spatial Association | *LISA* (pg. 3)   
Understand how to read in a variety of formats | `st_read()` (pg. 6)  
Know how to reorder data | `order()` (pg. 16) 
Know how to use buffers within R  | `st_buffer()` (pg. 19)   
<!-- Understand creating and using functions within R | `function ()` (pg. 13)  -->  
<!-- Tables have a max line length, if it is too long, the table gets shrunk -->


# Practical 1: Spatial Analysis

We are going to be performing some Exploratory Data Analysis using a program called GeoDa. The data we are using covers Manchester, UK. 

For the analysis, we are interested in the deprivation levels. First of all, let's have a look at the data in a program called GeoDa.

Download the data from http://bit.ly/csaprac1 or OneDrive (GreaterManchester_lsoa_2011_imd.zip) and extract the zip file. 

- Click **Start > GeoDa** 
- When GeoDa opens, click on the folder icon 
- Select **ESRI Shapefile (.shp)** 
- Browse to and open **GreaterManchester_lsoa_2011_imd.shp** 

![](images/geoda-file-open-shape-file.png){ height=30% }



GeoDa should open a map display of the data automatically. We can create a simple choropleth map in here by right clicking on the map and then select **Change Current Map Type**. Select **Natural Breaks > 5** and choose the variable to map (we want **IMDscore**). Then a classified map will appear, similar to one we have created in RStudio. 

Also open the attribute table ![Attribute Table](images/attribute-table.png){ height=20 } and a histogram ![Histogram](images/histogram.png){ height=20 } for `IMDscore`. GeoDa allows us to use brushing or linked displays. Select one of the larger bars in the histogram and you will see that the same entries are highlighted on the map and in the attribute table. You can also draw a box on the map (left-click and drag) and that will highlight the entries as well (you can drag the box around). 

*How is this different to interacting with the data in RStudio, or QGIS/ArcGIS if you have used those packages? Is it better / easier to use? Or harder to use?*

We will now perform some spatial analysis within GeoDa. There is some preparatory work to do beforehand, which is creating the spatial weights. This is how GeoDa works out which polygons are next to each other and which ones to include when running local analysis (these are how we define 'neighbours', as I mentioned in the presentation).

Select **Tools > Weights Manager** and click **Create**.  The following screen is displayed. 

![](images/weights.png){ height=40% }

- Select **Add ID Variable...** and accept the default name.  
- You now need to choose the neighbourhood weight method.  Select **Queen Contiguity** and click **Create**.  
- The neighbourhood weight matrix is saved in a file.  A suggested name is given.  This is the LSOA shape file name with a suffix of .gal.  Select **Save** and after a few seconds you should see a message **Weights file `GreaterManchester_lsoa_2011_IMD.gal` created successfully**.  
- Click **OK** on this window and **Close** on the Weights File Creation window. The Weights Manager window should show the details of the neighbours you have just selected. 

Click ![](images/histogram-button.png){ height=20 } and you can see how many neighbours each polygon has. In my data, five is the most common number of neighbours. Close this and open the **Connectivity Map**, which shows the neighbours for each polygon. Close this and the Weights Manager when you are happy with it. 

## Moran's I

We can now start to explore the spatial patterns of the model we want to develop.  Click on the **Space** item on the GeoDa menu.  First we are going to look at the global indicator of spatial autocorrelation.  Select the first menu item **Univariate Moran's I**.  A list of variables is displayed.  Choose the `IMDscore` variable.  Select the weights file we created earlier. 

![](images/morans-i.png){ height=40% }

A new window opens with a scatterplot of the IMDscore variable and the lagged IMDscore variable.  The lagged IMDscore variable is the value of the IMD Score for the selected neighbourhood and its neighbours as defined when we set the spatial weights.  The scatter-plot suggests a positive correlation between the variables.  This means that there is a weak positive spatial autocorrelation. It has a value of 0.253 confirming this positive spatial autocorrelation. We will now look at the local indicators of spatial association.  

## Local Indicators of Spatial Association (LISA)

- Select **Space > Univariate Local Moran's I**. 
- Select the `IMDscore` variable from the list displayed and select the weights file used earlier (it should be selected automatically). 
- A screen with three checkboxes is shown.  Check all three and click **OK**.  A number of windows are produced. 
- The scatterplot is the same as we produced in the previous section. The two maps shown below are produced.  You will probably need to expand them to full screen to see the legends and patterns displayed. 

![](images/lisa.png){ height=35% }

The first map shows the extent to which neighbouring areas are clustered:  
  
- red areas are neighbourhoods with a high proportion of deprived areas surrounded by similar neighbourhoods 
- darker blue areas are neighbourhoods with a low proportion of deprived areas surrounded by similar neighbourhoods 
- lighter blue areas are neighbourhoods with a low proportion of deprived areas surrounded by neighbourhoods with a high proportion of deprived areas 
- pink areas are neighbourhoods with a high proportion of deprived areas surrounded by neighbourhoods with a low proportion of deprived areas 
- white areas are neighbourhoods where the surrounding neighbourhoods do not generate a statistically significant relationship. 

The second map shows the level of statistical significance.  The values are 0.05, 0.01 and 0.001.

We can see that areas of high and low deprivation cluster together.

Now that we have the clustering output, we can save these to the shapefile and then load them into R to map or to do other analysis. *Moving data from one GIS application to another is something that happens regularly with many of the projects I am working on!* 

Right click on the map and choose **Save Results**. Tick all three boxes (to save all of the results). This will create a new variable in the shapefile for each of the results we are saving. It should look like this:

![](images/save-lisa.png){ height=20% }

Open the attribute table within GeoDa ![](images/attribute-table.png){ height=20 } and you can see the three new variables on the right hand side of the table. Click the Save button ![](images/save.png){ height=20 } to save the updated shapefile. 

## Moran's I in R (optional exercise)

We can also perform the same analysis in R. Load this shapefile back into RStudio. We need to use the `SP` library for these commands.  

```{r, message=FALSE, warning=FALSE, comment=NA, display=FALSE, results='hide'}
#load library
  library(rgdal)
#read in file
  GreaterManchester_lsoa_2011_imd <- readOGR(".", "GreaterManchester_lsoa_2011_imd")
```

Your data should look like this:

```{r, comment = NA}
head(GreaterManchester_lsoa_2011_imd@data)
```

To do the Moran's I analysis, we need another library:

```{r, comment=NA, message=FALSE, display=FALSE, warning = FALSE}
#load the library
  library(spdep)
#work out the neighbours
  GreaterManchester_lsoa_nb <- poly2nb(GreaterManchester_lsoa_2011_imd)
#reformat the list of neighbours to a weight matrix
  GreaterManchester_lsoa_lw <- nb2listw(GreaterManchester_lsoa_nb)
#run the test
  moran.test(GreaterManchester_lsoa_2011_imd@data$IMDscore, GreaterManchester_lsoa_lw)
```

This gives us the Moran's I statistic, as well as some associated variables. It is possible to run a whole range of analysis, which goes beyond the scope of this course. 

*Very recently, there is now a R library that allows us to do some of the GeoDa analysis in R - have a look at https://geodacenter.github.io/rgeoda/.*

# Practical 2: Mapping and R/RStudio Recap

We are going to be looking at a range of data for Greater Manchester and we'll be using both RStudio and GeoDa. 

This is a good time to remind you about using scripts (i.e. make sure you use one!). It's also a good idea to use the project facility within RStudio. To do this, open RStudio, click **File > New Project...**. Then click **New Directory > Empty Project**, select a folder (e.g. Documents) and then type a new folder name where the project will be saved. Finally click **Create Project**. This will be your working directory. 

### Plotting maps using `sf`

First, let's load the libraries we need. 

```{r, message=FALSE, display=FALSE, comment = NA, display = FALSE}
library(sf)
library(tmap)
```

Next, read in some data and plot the data.

```{r, message=FALSE, display=FALSE, comment=NA, warning=FALSE, results='hide'}
#read in data (download from OneDrive)
  manchester_lsoa <- st_read("GreaterManchester_lsoa_2011.shp")
  
```

```{r, message=FALSE, display=FALSE, comment=NA, warning=FALSE}
#plot data
  qtm(manchester_lsoa)
```

Each LSOA has a code and a name, we are looking at a range of IMD values; we need to join the spatial data to the attribute data. Download the IMD data from **http://bit.ly/2kFAlex** (or https://www.gov.uk/government/uploads/system/uploads/attachment_data/file/467774/File_7_ID_2015_All_ranks__deciles_and_scores_for_the_Indices_of_Deprivation__and_population_denominators.csv). This file contains the IMD data for 2015 for all LSOAs in England.

*There are 3 measures in this data - the IMD score, rank and decile. We will primarily be using the score, where the area with the highest score is the most deprived (with a rank of 1 and in the first decile).*

Download the CSV file to your working directory, rename it to something more sensible like `imd.csv` and read it in:

*Renaming files with long names to a much shorter file name is a good way of avoiding typos.*

```{r, echo=FALSE}
imd <- read.csv("File_7_ID_2015_All_ranks__deciles_and_scores_for_the_Indices_of_Deprivation__and_population_denominators.csv", header = TRUE)
```

```{r, eval=FALSE}
imd <- read.csv("imd.csv", header = TRUE)
```

Using `head(imd)` we can see some of the field names are rather long. Shorten them in RStudio (using the code below). For the moment we only need the IMD Score, Rank and Decile fields. Delete the others and we can always add them back in later if we need them *(this is an advantage of having a well-commented script!)*. 

```{r, comment = NA}
#delete columns we don't need
  imd <- imd[,1:7]
#rename columns
colnames(imd) <- c("LSOAcode","LSOAname","LADcode","LADname","IMDscore","IMDrank","IMDdecile")
```

Next, we need to join the data together. 

```{r, comment = NA}
manchester_lsoa <- merge(manchester_lsoa, imd, by.x="CODE", by.y="LSOAcode")
```

You should have something like this:

```{r, comment = NA}
head(manchester_lsoa)
```

We can also now plot the IMD score across Greater Manchester, using `tmap` (this code should be familiar to you!):

```{r}
#load library
  library(tmap)
#using tmap
  tm_shape(manchester_lsoa) +
    tm_polygons("IMDscore", title = "IMD Score", palette = "Blues", style = "jenks") +
    tm_layout(legend.title.size = 0.8)
```

### Plotting maps using `sp`

We can also use `sp` instead of `sf`:

First, let's load one of the libraries we need (install it if you don't have it already). 

```{r, message=FALSE, display=FALSE, comment = NA, display = FALSE}
library(rgdal)
```

Next, read in some data and plot the data.

```{r, message=FALSE, display=FALSE, comment=NA, warning=FALSE, results='hide'}
#read in data
  manchester_lsoa <- readOGR(".", "GreaterManchester_lsoa_2011")
```

```{r, message=FALSE, display=FALSE, comment=NA, warning=FALSE}
#plot data
  plot(manchester_lsoa)
```

We can use the same `imd.csv` file from earlier:

```{r, echo=FALSE}
imd <- read.csv("File_7_ID_2015_All_ranks__deciles_and_scores_for_the_Indices_of_Deprivation__and_population_denominators.csv", header = TRUE)
```

```{r, eval=FALSE}
imd <- read.csv("imd.csv", header = TRUE)
```

```{r, comment = NA}
#delete columns we don't need
  imd <- imd[,1:7]
#rename columns
colnames(imd) <- c("LSOAcode","LSOAname","LADcode","LADname","IMDscore","IMDrank","IMDdecile")
```

Next, we need to join the data together. Note how the code is slightly different:

```{r, comment = NA}
manchester_lsoa@data <- merge(manchester_lsoa@data,imd,by.x="CODE",by.y="LSOAcode", all.x=TRUE)
```

You should have something like this:

```{r, comment = NA}
head(manchester_lsoa@data)
```

We can also now plot the IMD score across Greater Manchester, using `tmap` (this code should be familiar to you!):

```{r}
#load library
  library(tmap)
#using tmap
  tm_shape(manchester_lsoa) +
    tm_polygons("IMDscore", title = "IMD Score", palette = "Blues", style = "jenks") +
    tm_layout(legend.title.size = 0.8)
```

**Make sure you are happy with the code you have used. Check the glossary, help in RStudio (`?functionname`) or Google for any functions you have not come across before.**

### Plotting the map using `base` R (optional exercise)

We can also plot the data with the code using the base `plot()` command, not making use of the `tmap` library:

```{r, comment = NA, display = FALSE, message = FALSE, warning=FALSE}
#load libraries
  library(maptools)
  library(classInt)
  library(RColorBrewer)
#select variable to map
  var <- manchester_lsoa@data[,"IMDscore"]
#set colours & breaks
  breaks <- classIntervals(var, n = 6, style = "fisher")
  my_colours <- brewer.pal(6, "Blues")
#plot map
  plot(manchester_lsoa, col = my_colours[findInterval(var, breaks$brks, all.inside = TRUE)], 
       axes = FALSE, border = rgb(0.8,0.8,0.8,0)) 
  #the 4th parameter in the RGB value is transparency and 
  #0 means transparent (so we don't get a border at all).
#draw legend
  legend(x = 350382, y = 392310, legend = leglabs(breaks$brks), fill = my_colours, 
         bty = "n", cex = 0.7)
#add a title
  title("Greater Manchester: IMD 2015 Score by LSOA")
```

Now we have a map of IMD by LSOA in Greater Manchester. 




# Practical 3: Spatial Decision Making

Public transport has an important role to play in tackling deprivation. We can use RStudio to see where the trams in Manchester run and how they relate to deprived areas. 

Firstly, we need to load some libraries (`sf` and `tmap`) and a new one - `tidyverse`. Remember to install it if you need to. Then we need to read in and join the LSOA data. 

```{r, comment=NA, message=FALSE, warning=FALSE, results='hide'}
library(sf)
library(tmap)
library(tidyverse)
#read in manchester LSOA data
  manchester_lsoa <- st_read("GreaterManchester_lsoa_2011.shp")
#join IMD data
  imd <- read.csv("imd.csv", header = TRUE)
  #delete columns we don't need
  imd <- imd[,1:7]
  #rename columns
  colnames(imd) <- c("LSOAcode","LSOAname","LADcode","LADname","IMDscore","IMDrank","IMDdecile")
  head(imd)
  manchester_lsoa <- merge(manchester_lsoa, imd, by.x = "CODE", by.y = "LSOAcode")
  head(manchester_lsoa)
```
  
Secondly, load the tramline data, available as a GeoJSON file. This is a different type of file to a shape file and is an XML based format (open it in Notepad if you are interested in how it is structured). `readOGR()` can read all sorts of file formats, so we can adapt the code easily.   
  
```{r, comment=NA, message=FALSE, warning=FALSE, results='hide'}
  #download data
  download.file("http://www.nickbearman.me.uk/data/r/tram.zip","tram.zip")
#unzip
  unzip("tram.zip")
#read in tramline data
  tramlines <- st_read(dsn = "tramlines.geojson")
```

We also need the tram stations, which are only available as a CSV file with Eastings and Northings. 

```{r, comment=NA, message=FALSE, warning=FALSE, results='hide'}
#read in CSV with tram station locations
  tram_stations_CSV <- read.csv("metrolink-stations.csv", header = TRUE)
```

Read the CSV file in (`metrolink-stations.csv`) and it should look like this:

```{r, comment=NA}
head(tram_stations_CSV)
```

We now need to convert this to a `sf` layer, like we did with the crime data in the Introduction course. 

From `head(tram_stations_CSV)`, we can see that the data consists of a number of columns, each with a heading. Two of these are called **X** and **Y**. These are the columns that give the coordinates (Eastings and Northings, as they are in BNG) of each station in the data you have just downloaded. There are also other columns, with various information. At the moment, the data is just in a data frame object - not any kind of spatial object.  To turn it into a spatial layer, enter the following:

```{r, comment=NA,warning=FALSE,message=FALSE}
#make as a sf layer
tram_stations <- st_as_sf(tram_stations_CSV, coords = c('X', 'Y'), crs = 27700)
```

This function `st_as_sf() is a generic function allowing us to create `sf` objects. In this case it takes the `tram_stations_CSV` variable, extracts the coodinates `coords = c('X', 'Y')` and sets the CRS to British National Grid ` crs = 27700`. 

Try `head(tram_stations)` to see the attribute table, similar to earlier. 

We can also plot the data, on top of the Greater Manchester LSOAs. 

```{r, comment=NA,warning=FALSE,message=FALSE}
#plot just tram stations
tm_shape(tram_stations) +
  tm_dots(tram_stations, size = 0.1, shape = 19, col = "darkred") 
#plot tram stations and LSOAs
tm_shape(tram_stations) +
  tm_dots(tram_stations, size = 0.1, shape = 19, col = "darkred") + 
  tm_shape(manchester_lsoa) +
  tm_borders()

```

We can see what the deprivation level is at each tram station, using a point in polygon analysis. The points are the tram stations and the polygons are the LSOAs. 

```{r, comment=NA,warning=FALSE,message=FALSE,error=FALSE}
#spatial join
stations_in_LSOA <- st_join(tram_stations, manchester_lsoa)

#view the data
stations_in_LSOA %>% View()
# the %>% (known as a pipe) is a piece of code from the tidyverse
```

At the moment, we have just picked one tram stations for reach LSOA. Most LSOAs only have one tram station in them, so this isn't a problem. However some LSOAs have more than on tram station in them. We can see this by counting how many tram stations are in each LSOA:

```{r, comment=NA,warning=FALSE,message=FALSE,error=FALSE}
#count stations in LSOA
stations_in_LSOA_count <- count(as_tibble(stations_in_LSOA), LSOAname) %>%
  print()
```

This will output the data to the console. If we want it in a view tab, do this:

```{r, comment=NA,warning=FALSE,message=FALSE,error=FALSE}
#count stations in LSOA
stations_in_LSOA_count <- count(as_tibble(stations_in_LSOA), LSOAname) %>%
  View()
```

Have a look in `stations_in_LSOA` for the LSOA `Trafford 004D` - you can see it is listed twice. For the moment we are just going to ignore this - but it is an issue with our analysis, and we will come back to it layer on.

Using the pipe `%>%` doesn't actually save the variable - it temporarily creates it and sends it to the `View()` function (in our case). However we need to use `stations_in_LSOA_count` later, so make sure you create it:

```{r, comment=NA,warning=FALSE,message=FALSE,error=FALSE}
#count stations in LSOA
stations_in_LSOA_count <- count(as_tibble(stations_in_LSOA), LSOAname)
```

## Reordering data

There is an `order()` function in R that allows us to reorder data. This is particularly useful if we want to display the 10 most and 10 least deprived stations! This code below creates a new variable with the data in a different order.

```{r, comment = NA}
stations_in_LSOA <- stations_in_LSOA[order(stations_in_LSOA$IMDscore, decreasing = TRUE), ]
```

We can then plot the top and bottom 10 stations:

```{r, comment = NA}
#stations
tm_shape(stations_in_LSOA) +
  tm_dots(stations_in_LSOA, size = 0.1, shape = 19, col = "darkred") 

#show top / bottom stations
tm_shape(stations_in_LSOA) +
  tm_dots(stations_in_LSOA, size = 0.1, shape = 19, col = "darkred") +
  tm_shape(stations_in_LSOA[1:10,]) +
  tm_dots(stations_in_LSOA[1:10,], size = 0.1, shape = 19, col = "red") +
  tm_shape(stations_in_LSOA[82:92,]) +
  tm_dots(stations_in_LSOA[82:92,], size = 0.1, shape = 19, col = "blue") 
```
  
So, which tram stop is the most deprived? and which is the least deprived?
  
```{r, comment = NA,warning=FALSE,message=FALSE,error=FALSE, results='hide'}
#most deprived
stations_in_LSOA[1,]
#least deprived
stations_in_LSOA[92,]
```

<!-- DROPPED STILL SP
## Creating a Function (optional exercise)

The code for doing a spatial join can easily be turned into a function within R. A function allows us to repeat a section of code with different data, without having to type out all of the lines again. This also hides some of the complexity from the user. For example, if we wanted to do a spatial join between railway stations and LSOAs, we could just substitute railway stations for trams. A function we have written ourselves works exactly the same way as many other functions we have used (`read.csv()`, `readOGR()`, etc.). Running a `SpatialJoin()` function we have written would look a bit like this:

```{r, comment=NA,warning=FALSE,message=FALSE, eval = FALSE}
tram_stations_joined <- SpatialJoin(tram_stations, manchester_lsoa)
```

Where `tram_stations` and `manchester_lsoa` are the parameters, `SpatialJoin` the function name and `tram_stations_joined` the output. Currently, if you ran the line above, R would give an error message, as it doesn't know what that function is. To create the function (and it will appear in the environment list on the right) run this code:

```{r, comment=NA,warning=FALSE,message=FALSE}
#function to join points with the attribute data of the polygons they overlay
SpatialJoin <- function(pts, polys) {
  #error checking
    if (!inherits(polys, "SpatialPolygonsDataFrame")) 
        stop("MUST BE SP SpatialPolygonsDataFrame OBJECT")
    if ((inherits(pts, "SpatialPointsDataFrame") | inherits(pts, "SpatialPoints")) == FALSE) 
        stop("Must be sp SpatialPointsDataFrame object")
  #extract points in overlay
    z <- pts[!is.na(over(pts, geometry(polys))),]
  #join attribute data  
    z@data <- data.frame(z@data, na.omit(over(pts,polys)) )
  #update projection
    z@proj4string <- pts@proj4string
  #return z
    z
}     
```

In a function it is common to use generic terms to refer to the inputs and outputs (e.g. pts, polys, z), because the function doesn't know (or care) whether we are dealing with tram stations or railway stations - it just cares that it is a point (or polygon) layer. 

This is where error checking comes in, which is what takes up the first half of the function. These check whether the poly variable is a polygon and the pts variable a points layer. If they are not, it will stop running and generate an error message. Try creating the function and running it. 

We can then repeat the process of working out which train station is the most and least deprived. The train stations for Manchester are included in the tram.zip file as `rail-stations.geojson` (originally from https://data.gov.uk/dataset/metrolink-and-rail-stations). Try writing the code to read the data in, join it, reorder it and display it on the map. 


-->

## Tram Stop Buffers

Currently we have been looking at just the LSOA each tram stop is within. However we could look at the LSOAs that are within a set distance (for example a 15 minute walk) of each tram stop. Why do you think we might we want to do this?

For this, we need to use a buffer - a circle of a set distance around each tram stop. At a speed of 3 mph, this is equal to about 1.2km. We can use the `st_buffer` function. 

```{r, comment = NA}
#plot the tram stations
  qtm(tram_stations)
#calculate the buffer (distance is 1200 meters)
  tram_stations_1200_buffer <- st_buffer(tram_stations, 1200)
#plot the buffer
  qtm(tram_stations_1200_buffer)
```

We now have the buffers (the circles) for each tram station. There are a number of different ways we can look at how the buffers and LSOAs relate to one another. We are going to look at a quite simple approach - convert the LSOAs to points and for each buffer take the average deprivation level of the LSOAs within the buffer. 

**There are a number of limitations with this method and this is something to think about as you work through this process: how could you do the analysis differently in the future?**

First, we need to convert the LSOA polygons into points. Fortunately, there is a function (`st_centroid()`) which will do this for us. This calculates the centre point (centroid) for each LSOA. The function creates a `sf` data frame.

```{r, comment = NA}
#convert polygons to points  
  manchester_lsoa_points <- st_centroid(manchester_lsoa) 
#plot points
  qtm(manchester_lsoa_points)
#plot points and LSOA
  tm_shape(manchester_lsoa) +
  tm_borders(col = "red") +
  tm_shape(manchester_lsoa_points) +
  tm_dots(manchester_lsoa_points, size = 0.1, shape = 19, col = "darkred") 
```

We also still have the IMD data in the variable:

```{r, comment = NA}
View(manchester_lsoa_points)
```

Now we have the train stations buffers as polygons and the LSOAs as points (as shown in the plot above). We can do the overlay manually by plotting the different data sets on top of one another. 

```{r, comment = NA}
#map of one station buffer with LSOA points in it
tm_shape(tram_stations_1200_buffer[1,]) +
  tm_borders(col = "red") +
  tm_shape(manchester_lsoa_points) +
  tm_dots(manchester_lsoa_points, size = 0.1, shape = 19, col = "darkred") 
```

However, to link the two we need to do a spatial join. This is similar to what we did earlier. 

```{r, comment = NA}
#st_join is a left join
#join each station to the LSOAs within the buffer
  tram_stations_IMD <- st_join(tram_stations_1200_buffer, manchester_lsoa_points)
  View(tram_stations_IMD)
```

Each station (`tram_stations_1200_buffer`) is listed multiple times - one for each LSOA (`manchester_lsoa_points`) which falls within the buffer. We can group this:

```{r, comment = NA}
#group by Station, take average IMDscore. 
  station_LSOA_IMD <- tram_stations_IMD %>% group_by(Label_Text) %>% summarise(mean(IMDscore)) 
#view the average IMD score for each station
View(station_LSOA_IMD)
qtm(station_LSOA_IMD)
```

Now we have each station buffer listed once, with the average IMD score (`mean(IMDscore)`). Currently they are still the buffers, which won't make sense to map, so we can convert them back to points (centriods):

```{r, comment = NA}
#still buffers (of each station), so convert to points (centriods)
station_LSOA_IMD_pt <- st_centroid(station_LSOA_IMD)
qtm(station_LSOA_IMD_pt)
```

Now we can map them:

```{r, comment = NA}
tm_shape(tram_stations_1200_buffer) +
  tm_borders(col = "red") +
  tm_shape(station_LSOA_IMD_pt) +
  tm_dots(station_LSOA_IMD_pt, size = 0.1, shape = 19, col = "darkred")
```

We can then reorder them, and map them according to the IMD:

```{r, comment = NA}
#reorder, most deprived at the top
station_LSOA_IMD_pt_ordered <- station_LSOA_IMD_pt[order(station_LSOA_IMD_pt$`mean(IMDscore)`, decreasing = TRUE), ]

head(station_LSOA_IMD_pt_ordered)

#plot map of average IMD score by station (top 10 in Red, bottom 10 in Blue)
tm_shape(station_LSOA_IMD_pt_ordered) +
  tm_dots(station_LSOA_IMD_pt_ordered, size = 0.1, shape = 19, col = "darkred") +
  tm_shape(station_LSOA_IMD_pt_ordered[1:10,]) +
  tm_dots(station_LSOA_IMD_pt_ordered[1:10,], size = 0.1, shape = 19, col = "red") +
  tm_shape(station_LSOA_IMD_pt_ordered[81:91,]) +
  tm_dots(station_LSOA_IMD_pt_ordered[81:91,], size = 0.1, shape = 19, col = "blue") 
```


We now have the average deprivation for each tram stop. **How is this different to our previous measure? What are the limitations?** 
  
- Discuss your results with a neighbour. How could the deprivation be calculated differently? 
- Try running the analysis with a different buffer. How easy is this within R compared to another GIS? 
- How about doing a polygon polygon overlay? How easy is this in R compared to another GIS? *See http://gis.stackexchange.com/questions/140504/extracting-intersection-areas-in-r for some interesting suggestions.*


## Future Developments (optional exercise)

We can extend this principle to look at groups of tram stops (either using just the stop location, or the buffer approach. For example, let's say there are some prospective new tram routes which could be built (see `future_tramlines` and `future_tramstops`).

We need to decide which route is the most important. For this exercise we are going to say that the route that gives access to the most deprived area(s) will be our recommended route (obviously there are many other factors that could be involved!). 

**Analyse the prospective new routes to see which reaches the areas with highest deprivation levels.**


-----

# Practical 3: Spatial Decision Making - SP Version

Public transport has an important role to play in tackling deprivation. We can use RStudio to see where the trams in Manchester run and how they relate to deprived areas. 

Firstly, load the tramline data, available as a GeoJSON file. This is a different type of file to a shape file and is an XML based format (open it in Notepad if you are interested in how it is structured). `readOGR()` can read all sorts of file formats, so we can adapt the code easily. 

```{r, comment=NA, message=FALSE, warning=FALSE, results='hide'}
library(rgdal)
#read in and join manchester data
  manchester_lsoa <- readOGR(".", "GreaterManchester_lsoa_2011")
imd <- read.csv("imd.csv", header = TRUE)
  #delete columns we don't need
  imd <- imd[,1:7]
#rename columns
colnames(imd) <- c("LSOAcode","LSOAname","LADcode","LADname","IMDscore","IMDrank","IMDdecile")
  manchester_lsoa@data <- merge(manchester_lsoa@data,imd,by.x="CODE",by.y="LSOAcode", all.x=TRUE)
  head(manchester_lsoa@data)
  
#download data
  download.file("http://www.nickbearman.me.uk/data/r/tram.zip","tram.zip")
#unzip
  unzip("tram.zip")
#read in tramline data
  tramlines <- readOGR(dsn = "tramlines.geojson")
#if this doesn't work, try:
# tramlines <- readOGR(dsn = "tramlines.geojson", layer="OGRGeoJSON")
```

We also need the tram stations, which are only available as a CSV file with Eastings and Northings. 

```{r, comment=NA, message=FALSE, warning=FALSE, results='hide'}
#read in CSV with tram station locations
  tram_stations_CSV <- read.csv("metrolink-stations.csv", header = TRUE)
```

Read the CSV file in (metrolink-stations.csv) and it should look like this:

```{r, comment=NA}
head(tram_stations_CSV)
```

We now need to convert this to a `SpatialPointsDataFrame`, like with the crime data in the Introduction course. 

From `head(tram_stations_CSV)`, we can see that the data consists of a number of columns, each with a heading. Two of these are called **X** and **Y**. These are the columns that give the coordinates (Eastings and Northings, as they are in BNG) of each station in the data you have just downloaded. There are also other columns, with various information. At the moment, the data is just in a data frame object - not any kind of spatial object.  To turn it into a SpatialPointsDataFrame, enter the following:

```{r, comment=NA,warning=FALSE,message=FALSE}
#extract coordinates
  coords <- cbind(Easting = tram_stations_CSV$X, Northing = tram_stations_CSV$Y)
#create spatialPointsDataFrame, removing coordinates from the @data element
#we can use the same projection information as manchester_lsoa as we know it is identical
  tram_stations <- SpatialPointsDataFrame(coords, tram_stations_CSV[, -(1:2)], 
                                    proj4string = manchester_lsoa@proj4string)
```

This creates a ```SpatialPointsDataFrame``` object. This second line (starting `coords`) prepares the coordinates into a form that the ```SpatialPointsDataFrame``` can use. The ```SpatialPointsDataFrame``` function on the forth line takes three arguments - the first is coordinates, created in the line above. The second argument is the data frame **minus** (i.e. not including) columns 1 and 2 - this is what ```-(1:2)``` indicates.  These columns provide all the non-geographical data from the data frame.  The third is the coordinate system that the data is currently in (British National Grid). The resulting object ```tram_stations``` is a spatial points geographical shape object,  whose points are each recorded crime in the data set you download.  

Try `head(tram_stations@data)` to see the attribute table, similar to earlier. 

We can also plot the data, on top of the Greater Manchester LSOAs. Note the change in colour (`col`) and size (`cex` for points and `lwd` for lines), to make the lines and stations more visible. We can also use different symbols, by substituting in `pch = 1` for `pch="."`. Try searching in Google "R plot pch" and see what the different options are. 

```{r, comment=NA,warning=FALSE,message=FALSE}
#plot LSOAs
plot(manchester_lsoa)
#plot tram lines, in blue
plot(tramlines, col = "blue", lwd = 5, add = TRUE)
#plot stations, in red
plot(tram_stations, pch = ".", col = "red", cex = 5, add = TRUE)
```

We can see what the deprivation level is at each tram station, using a point in polygon analysis. The points are the tram stations and the polygons are the LSOAs. 

```{r, comment=NA,warning=FALSE,message=FALSE,error=FALSE}
# This is another R package, allowing GIS overlay operations
  library(rgeos) 
# this extracts the tram stations that are over the LSOAs (all of them in our case)
  z <- tram_stations[!is.na(over(tram_stations, geometry(manchester_lsoa))),]
# this takes the attribute data from the LSOA that contain the tram_stations, 
  #and adds it to the data frame of z     
    z@data <- data.frame(z@data, na.omit(over(tram_stations, manchester_lsoa)))
#this copies the project from tram_stations to z    
    z@proj4string <- tram_stations@proj4string
#copy z to tram_stations_joined
    tram_stations_joined <- z
#preview data
    head(tram_stations_joined)
```

Z is just a temporary variable to hold the updated tram_stations information. If we wanted to be tidy, we should really delete the z variable when we have finished: `rm(z)` 

## Reordering data

There is an `order()` function in R that allows us to reorder data. This is particularly useful if we want to display the 10 most and 10 least deprived stations! This code below creates a new variable with the data in a different order.

```{r, comment = NA}
tram_stations_joined_reordered <- 
  tram_stations_joined[order(tram_stations_joined@data$IMDscore, decreasing = TRUE),]
```

We can then plot the top and bottom 10 stations:

```{r, comment = NA}
plot(tram_stations_joined_reordered[1:10,], col = "red")
plot(tram_stations_joined_reordered[81:91,], col = "blue", add = TRUE)
```
  
So, which tram stop is the most deprived? and which is the least deprived?
  
```{r, comment = NA,warning=FALSE,message=FALSE,error=FALSE, results='hide'}
#most deprived
tram_stations_joined_reordered[1,]
#least deprived
tram_stations_joined_reordered[91,]
```

Can you create a map similar to this (see over), with the 10 most deprived stations in red and the top 10 least deprived stations in blue as well as identifying the most and least deprived stations? As an optional extra, see if you can include an appropriate legend and title.

```{r, comment = NA, echo=FALSE}
plot(tramlines)
plot(tram_stations, pch=".", cex = 3, add = TRUE)
plot(tram_stations_joined_reordered[1:10,], pch=".", cex = 5, col = "red", add = TRUE)
plot(tram_stations_joined_reordered[81:91,], pch=".", cex = 5, col = "blue", add = TRUE)
plot(tram_stations_joined_reordered[1,], pch=".", cex = 9, col = "red", add = TRUE)
plot(tram_stations_joined_reordered[91,], pch=".", cex = 9, col = "blue", add = TRUE)
```

## Creating a Function (optional exercise)

The code for doing a spatial join can easily be turned into a function within R. A function allows us to repeat a section of code with different data, without having to type out all of the lines again. This also hides some of the complexity from the user. For example, if we wanted to do a spatial join between railway stations and LSOAs, we could just substitute railway stations for trams. A function we have written ourselves works exactly the same way as many other functions we have used (`read.csv()`, `readOGR()`, etc.). Running a `SpatialJoin()` function we have written would look a bit like this:

```{r, comment=NA,warning=FALSE,message=FALSE, eval = FALSE}
tram_stations_joined <- SpatialJoin(tram_stations, manchester_lsoa)
```

Where `tram_stations` and `manchester_lsoa` are the parameters, `SpatialJoin` the function name and `tram_stations_joined` the output. Currently, if you ran the line above, R would give an error message, as it doesn't know what that function is. To create the function (and it will appear in the environment list on the right) run this code:

```{r, comment=NA,warning=FALSE,message=FALSE}
#function to join points with the attribute data of the polygons they overlay
SpatialJoin <- function(pts, polys) {
  #error checking
    if (!inherits(polys, "SpatialPolygonsDataFrame")) 
        stop("MUST BE SP SpatialPolygonsDataFrame OBJECT")
    if ((inherits(pts, "SpatialPointsDataFrame") | inherits(pts, "SpatialPoints")) == FALSE) 
        stop("Must be sp SpatialPointsDataFrame object")
  #extract points in overlay
    z <- pts[!is.na(over(pts, geometry(polys))),]
  #join attribute data  
    z@data <- data.frame(z@data, na.omit(over(pts,polys)) )
  #update projection
    z@proj4string <- pts@proj4string
  #return z
    z
}     
```

In a function it is common to use generic terms to refer to the inputs and outputs (e.g. pts, polys, z), because the function doesn't know (or care) whether we are dealing with tram stations or railway stations - it just cares that it is a point (or polygon) layer. 

This is where error checking comes in, which is what takes up the first half of the function. These check whether the poly variable is a polygon and the pts variable a points layer. If they are not, it will stop running and generate an error message. Try creating the function and running it. 

We can then repeat the process of working out which train station is the most and least deprived. The train stations for Manchester are included in the tram.zip file as `rail-stations.geojson` (originally from https://data.gov.uk/dataset/metrolink-and-rail-stations). Try writing the code to read the data in, join it, reorder it and display it on the map. 


## Tram Stop Buffers

Currently we have been looking at just the LSOA each tram stop is within. However we could look at the LSOAs that are within a set distance (for example a 15 minute walk) of each tram stop. Why do you think we might we want to do this?

For this, we need to use a buffer - a circle of a set distance around each tram stop. At a speed of 3 mph, this is equal to about 1.2km. We can use the `gBuffer` function, from the `rgeos` library. 

```{r, comment = NA}
#plot the tram stations
  plot(tram_stations_joined)
#calculate the buffer (distance is 1200 meters)
  tram_stations_joined_buffer <- gBuffer(tram_stations_joined, width = 1200, byid = TRUE)
#plot the buffer (add to existing plot)
  plot(tram_stations_joined_buffer, add = TRUE)
```

We now have the buffers (the circles) for each tram station. There are a number of different ways we can look at how the buffers and LSOAs relate to one another. We are going to look at a quite simple approach - convert the LSOAs to points and for each buffer take the average deprivation level of the LSOAs within the buffer. 

**There are a number of limitations with this method and this is something to think about as you work through this process: how could you do the analysis differently in the future?**

First, we need to convert the LSOA polygons into points. Fortunately, there is a function (`gCentroid()`) which is part of the `rgeos` package which will do this for us. This calculates the centre point (centroid) for each LSOA. The function creates a `SpatialPoints` variable, which doesn't have an attribute table (`@data`), so we need to copy this over manually.

```{r, comment = NA}
#convert polygons to points  
  manchester_lsoa_points <- gCentroid(manchester_lsoa, byid = TRUE)  
  plot(manchester_lsoa_points)
#create coordinates
  coords = data.frame(manchester_lsoa_points@coords[,1:2])
#create SpatialPointsDataFrame using coords and data
  manchester_lsoa_points <- SpatialPointsDataFrame(coords, data=data.frame(
    manchester_lsoa@data$IMDscore), proj4string= manchester_lsoa@proj4string)
#plot points  
  plot(manchester_lsoa_points)
#show head
  head(manchester_lsoa_points@data)
#plot first tram station
  plot(tram_stations_joined_buffer[1,])  
#plot lsoa points on top
  plot(manchester_lsoa_points, add = TRUE)  
```

Now we have the train stations buffers as polygons and the LSOAs as points (as shown in the plot above). We can do the overlay manually by plotting the different data sets on top of one another (as we did above). However, R is unable to link each tramstop with the LSOAs within the buffer. For this we need to get R to do the overlay and save the associated information - i.e. the average IMD score for each tram station, based on the buffer. 

```{r, comment = NA}
#Create point in polygon list
  o <- over(tram_stations_joined_buffer,manchester_lsoa_points,returnList=TRUE)
#View length of the list
  length(o)
#If we examine the object o, we will see also see that this comprises a list of dataframes. 
#The summary function tells you about an object - head, is used to wrap around the function 
#so only the first six elements are shown
  head(summary(o))
#View an item from the list (in this case sixth) (i.e. the sixth tram station and all of 
#the LSOAs that are linked with it)
  o[[6]]
#get a list of those LSOAs that are within this buffer using the rownames
#make them numeric
  row_o <- as.numeric(rownames(o[[6]]))
#plot tram station buffer number 6
  plot(tram_stations_joined_buffer[6,])
#Plot all the LSOA centroids
  plot(manchester_lsoa_points,pch=19,cex=.5,col="#7F7F7F",add=TRUE)
#Plot those LSOA centroids which are inside the buffer - i.e. we use the row_o to select the rows
  plot(manchester_lsoa_points[row_o,],pch=15,cex=1,col="#FF4500",add=TRUE)
```

This shows the tram station buffer (the circle), all of the LSOA centroids (grey dots) and those LSOA centroids within the buffer (red squares). For each tram buffer, we need to calculate the average IMD score, as we are likely to have a range of deprivation levels within the tram station buffer. The `colMeans()` function will calculate the mean value for each column (as you might have guessed!). We want to do this for each tram station buffer and the `lapply()` function allows us to do this - to apply a function (`colMeans()`) across the list of tram station buffers. We can then join this back onto the tram_stations data frame. 

```{r, comment = NA}
  average_deprivation <- lapply(o, colMeans)
#View the first six items from the list
  average_deprivation[1:6]
#collapse list back into a normal data frame
  tram_deprivation <- data.frame(matrix(unlist(average_deprivation),
                                        nrow=length(average_deprivation), byrow=T))
#Change the column names to something sensible
  colnames(tram_deprivation) <- c("average_deprivation")
#This should look like
  head(tram_deprivation)
#Join - the ordering has not been changed so this is valid
  tram_stations@data <- cbind(tram_stations@data,tram_deprivation)
#show data
  head(tram_stations@data)
```  

We now have the average deprivation for each tram stop. **How is this different to our previous measure? What are the limitations?** Plot a map of your results. 
  
- Discuss your results with a neighbour. How could the deprivation be calculated differently? 
- Try running the analysis with a different buffer. How easy is this within R compared to another GIS? 
- How about doing a polygon polygon overlay? How easy is this in R compared to another GIS? *See http://gis.stackexchange.com/questions/140504/extracting-intersection-areas-in-r for some interesting suggestions.*

*If you want to install additional libraries, you can do this, but on centrally managed machines, it will only install onto that machine, so if you use a different machine you may need to rerun the installation command.*

## Future Developments (optional exercise)

We can extend this principle to look at groups of tram stops (either using just the stop location, or the buffer approach. For example, let's say there are some prospective new tram routes which could be built (see `future_tramlines` and `future_tramstops`).

We need to decide which route is the most important. For this exercise we are going to say that the route that gives access to the most deprived area(s) will be our recommended route (obviously there are many other factors that could be involved!). 

**Analyse the prospective new routes to see which reaches the areas with highest deprivation levels.**



-----  
  
  
This practical was written using R 4.2.0 (2022-04-22) and RStudio 2022.02.3 by Dr. Nick Bearman (nick@geospatialtrainingsolutions.co.uk). It has also been tested in R 4.2.0 (2022-04-22) and RStudio 2022.02.3 (RStudio Cloud).

This work (Confident Spatial Analysis and Statistics in R & GeoDa) is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/4.0/. <img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/cc.svg?ref=chooser-v1"><img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/by.svg?ref=chooser-v1"><img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/nc.svg?ref=chooser-v1"><img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/sa.svg?ref=chooser-v1">

The latest version of the PDF is available from https://github.com/nickbearman/confident-spatial-analysis. This is v5.0 and this was created on `r format(Sys.time(), '%d %B %Y')`.


